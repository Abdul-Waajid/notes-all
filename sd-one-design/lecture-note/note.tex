\documentclass[a4paper]{article}
\title{Software development one - Design}
\author{Riyazdeen Abdul Waajid}
\date{5th of October 2024}

\usepackage{parskip}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage[top=1in,bottom=1in,left=0.5in,right=0.5in]{geometry}
\usepackage{enumerate}

\usepackage{float}

\setlength{\parskip}{0.3 em}
\setlength{\parskip}{1em}  % Add 1em space between paragraphs
\setlength{\parindent}{0pt} % Disable paragraph indentation

\begin{document}
\maketitle
\tableofcontents    
\newpage    
\section{SDLC/Dev - Software development life cycle}
\subsubsection{\textbf{what is the Software Development life cycle?}}
It is a systematic process or set of phases that guide the development of software applications from conception to deployment and maintenance. 

In simple words it is to make an idea to manifest into reality, this idea could also
be the solution to a problem. This idea /solution will take its form over multiple
phases. This solution, which is the end product must also be distributable, and used by end users.

These phases are the standard set of steps to be followed when developing a software.
\parindent 0px

\textbf{The phases in the SDLC are:}
\begin{enumerate}
    \item Analysis phase  
    \item Design phase  
    \item Implementation
    \item Testing
    \item Deployment
    \item Maintenance
        

\end{enumerate}

The software development process is referred to as a cycle rather than a sequence because it is often iterative and repetitive.
In a sequence, each step would occur once in a linear order, but in a cycle, the process loops back on itself, allowing for 
continuous improvement, refinement of the software.
\subsection{Analysis phase - requirement gathering and analysis}
\textbf{Identify and understand the needs, and the requirements of the software.} Within this phase, the problem is to be
identified, the requirements are to be identified, and then an analysis of the problem
and the requirements are to be made.
Before starting any new task or development of a new software it is of utmost priority for the developer or anyone who 
undertakes development to understand
the exact requirements that are demanded by the task. 

To gather the requirements the developer must use elicitation methods, such as: 
\begin{itemize}
    \item observations
    \item interviews
    \item surveys
    \item research into literature
\end{itemize}    

Elicitation methods are techniques used to gather, extract, and understand requirements from stakeholders 
(such as clients, users, and subject matter experts) during the early stages of a project. These methods 
help ensure that the software or system being developed aligns with the needs and expectations of those who will use or benefit from it.
Elicitation methods are crucial in business analysis, system design, and project management to accurately capture functional and 
non-functional requirements.

Next in this phase, \textbf{the project scope must be defined, followed by documenting the functional and non-functional requirements.}

Defining the project scope establishes clear boundaries for the team, outlining the specific criteria that need to be fulfilled.
Everything within the scope represents what the system and developers are responsible for. Conversely, any requirements outside 
this scope are not part of the project and are not the developers' responsibility. This ensures that expectations are managed and the 
team focuses only on the agreed-upon deliverables.

\textbf{\textit{Extra notes from gpt starts here! }}

The scope of a project refers to the specific boundaries and objectives of the project, detailing what needs to be accomplished, including:

\begin{enumerate}
    \item Project Goals: The high-level objectives or outcomes the project is designed to achieve.
    \item Deliverables: The tangible outputs, such as products, features, or services, that the project will produce.
    \item Tasks and Activities: The work required to achieve the project's goals and deliverables.
    \item Exclusions: What is not included in the project (this helps prevent misunderstandings).
    \item Constraints: Limitations in terms of time, budget, resources, or technologies.
    \item Assumptions: Hypotheses or conditions assumed to be true for the project to proceed (e.g., resource availability).
    \item Stakeholders: Who will be involved in or affected by the project, such as clients, users, or team members.
\end {enumerate}

\textbf{Why Must the Scope Be Defined?}
    
Defining the project scope is crucial for the following reasons:
\begin{enumerate}
    \item Prevents Scope Creep 
    \begin{itemize}
        \item Scope creep refers to uncontrolled changes or additions to a project’s requirements without 
            corresponding changes in time, resources, or budget. When scope is clearly defined, it helps maintain focus on agreed-upon
            deliverables and prevents the project from expanding beyond its original boundaries. 
    \end{itemize}
    \item Establishes Clear Goals and Deliverables 
    \begin{itemize}
        \item A defined scope clarifies the objectives and expectations, ensuring all stakeholders understand what the project aims to 
            achieve. It acts as a guiding document to keep everyone aligned on the outcomes.
    \end{itemize}
    \item Resource Allocation 
    \begin{itemize}
        \item A well-defined scope helps determine the amount of time, budget, and resources needed for 
            the project. Without a clear scope, it's difficult to estimate these factors accurately, leading to overruns and inefficiencies.
    \end{itemize}
    \item Provides a Baseline for Planning 
    \begin{itemize}
        \item The project scope sets a foundation for more detailed project planning, including the schedule, costs, and 
            quality requirements. It helps in setting realistic timelines and milestones.
    \end{itemize}
    \item Manages Stakeholder Expectations 
    \begin{itemize}
        \item By clearly defining what the project will deliver (and what it won’t), you can manage stakeholder expectations from the start. 
            This helps avoid misunderstandings about what is in or out of scope, reducing the risk of dissatisfaction.
    \end{itemize}
    \item Helps in Risk Management 
    \begin{itemize}
        \item A clearly defined scope allows the team to identify potential risks that might arise from attempting to 
            achieve certain project deliverables. Understanding the project boundaries aids in risk assessment and mitigation planning.
    \end{itemize}
    \item Facilitates Change Control 
    \begin{itemize}
        \item Defining the scope provides a framework for handling change requests. Any changes to the project can be compared against the
            original scope, and the project team can assess how those changes would impact resources, time, and costs before deciding whether 
            to approve them.
    \end{itemize}
    \item Improves Project Control and Tracking
    \begin{itemize}
        \item Once the scope is defined, it serves as a baseline to measure progress and determine whether the project is on track. Deviations from 
            the scope can be identified early and corrected before they lead to significant issues.
    \end{itemize}
    \item Enhances Team Focus and Productivity 
    \begin{itemize}
        \item A clear scope gives the project team a clear understanding of their responsibilities 
            and tasks. With specific deliverables in mind, the team can stay focused and work efficiently toward the project goals.
    \end{itemize}
    \item Legal Protection
    \begin{itemize}
        \item In contractual or formal settings, the project scope serves as a reference to protect the project 
            team and stakeholders legally. If there are disputes about what was promised versus delivered, the defined scope provides a 
            solid basis for resolution.
    \end{itemize}
\end{enumerate}

\textbf{\textit{Extra notes from gpt end here! }}

\vspace{0.5 cm}
\subsubsection{\textbf{Functional Requirements and Non-functional requirements}}

\vspace{0.5 cm}
\begin{Large}\textbf{Functional requirements }\end{Large}

Functional requirements describe the specific behaviors or functions that a system must perform. 
The focus is on the actions and features the product will deliver. These requirements define what the system should do 
to fulfill its intended purpose.

A common approach for gathering and prioritizing functional requirements is based on the IEEE standards, often represented using 
the MoSCoW method. This format categorizes requirements based on their importance and necessity.

In the MoSCoW format, the requirements are grouped into the following categories:

\begin{enumerate}
    \item Must: Essential features the system is required to have. 
    \item Should: Important features that are not critical but highly desirable. 
    \item Could: Features that are nice to have if time and resources permit. 
    \item Won't (or Would): Features that are not considered at this stage but might be included in the future. 
\end{enumerate}

This approach helps prioritize the most critical requirements, ensuring that the system focuses on delivering what is absolutely necessary, 
while also considering enhancements when possible.

\textbf{\textit{Examples:}} 
    \begin{enumerate}[(a)]
        \item The user should be able to log into the dashboard using bio-metric credentials.  
    \end{enumerate}
\vspace{0.5 cm}

\textbf{\textit{Extra notes from gpt starts here! }}

{\raggedright \begin{large} Some functional requirements for a library system:\end{large}\par }
    \begin{enumerate}[(1)]
        \item User Registration and Authentication 
            \begin{itemize}
                \item  The system must allow users to create an account by providing personal details (e.g., name, email, ID). 
                \item  The system should provide a password recovery option.
                \item  User Registration and Authentication Users must be able to log in using their credentials (username/password 
                    or bio-metric login).
            \end{itemize}
        \item Book Search and Retrieval The system should display the availability status (available, checked out, reserved). 
            \begin{itemize}
                \item  Users must be able to search for books by title, author, genre, ISBN, or keywords. 
                \item  Users should be able to filter and sort search results by criteria like publication date or popularity.
            \end{itemize}
        \item Book Borrowing The system must track the due dates for borrowed items. 
            \begin{itemize}
                \item  Registered users must be able to borrow books by placing a hold on available items. 
                \item  Users should be able to extend loan periods if the book is not reserved by another user.
            \end{itemize}
        \item Book Reservation 
            \begin{itemize}
                \item  Users must be able to reserve books that are currently checked out. 
                \item  The system should notify users when a reserved book becomes available for pickup. 
            \end{itemize}
        \item Notifications and Alerts  
            \begin{itemize}
                \item  The system must notify users about overdue books via email or SMS.
                \item  The system should send reminders for upcoming due dates. 
                \item  Users should receive alerts when reserved books are available for pickup.
            \end{itemize}
        \item Catalog Management (For Admins/Librarians)  
            \begin{itemize}
                \item  Librarians must be able to add, update, or remove books from the system catalog.
                \item  The system should support bulk uploading of book data through CSV files or other formats.
                \item  The system must allow the classification of books by genres, authors, and categories.
            \end{itemize}
        \item Fine Calculation and Payment 
            \begin{itemize}
                \item  The system must calculate overdue fines based on the number of late days.
                \item  Users must be able to view their fine history and pay fines online.
            \end{itemize}
        \item User Account Management   
            \begin{itemize}
                \item  Users must be able to view their borrowing history.
                \item  The system must allow users to update their personal information.
                \item  Users should be able to view current borrowed books, due dates, and reservation statuses.
            \end{itemize}
        \item Library Hours and Information  
            \begin{itemize}
                \item  The system should display library hours, upcoming events, and holidays.
                \item  Users should be able to view the locations and contact information for different library branches.
            \end{itemize}
        \item Reports and Analytics (For Admins)
            \begin{itemize}
                \item  The system must generate reports on book circulation, user activity, and overdue items.
                \item  Librarians should be able to view analytics on popular books, genres, and user borrowing patterns.
            \end{itemize}
    \end{enumerate}
\textbf{\textit{Extra notes from gpt end here! }}

\vspace{0.5 cm}
\begin{Large}\textbf{Non-functional requirement}\end{Large}

Non-functional requirement specifies the quality attributes or the constrains the system must satisfy.

Non-functional requirements (NFRs) specify the criteria that can be used to judge the operation of a system, rather than specific behaviors. 
These requirements define how a system performs its functions rather than what functions it performs. They encompass various quality attributes and 
constraints that affect the user experience, performance, and overall system characteristics.

\textbf {Meaning of Non-Functional Requirements}

Non-functional requirements describe the quality attributes of a system, such as:
\begin{itemize}
    \item Performance: How quickly the system responds to user actions.
    \item Usability: How easy and intuitive the system is for users.
    \item Reliability: The system's ability to function under specific conditions without failure.
    \item Scalability: The capacity of the system to handle increased loads or expand in capability.
    \item Security: Measures to protect the system from unauthorized access or breaches.
    \item Maintainability: The ease with which the system can be modified or updated.
    \item Availability: The accessibility of the system to the users over a period of time.
\end{itemize}

\vspace{0.5 cm}
\textbf{\textit{Extra notes from gpt starts here! }}

\textbf{\textit{Examples of Non-Functional Requirements:}}

\begin{enumerate}
        \item Performance Requirements
\begin{itemize}
        \item The system should respond to user queries within 2 seconds under normal load conditions.
        \item The system must support 100 concurrent users without performance degradation.
\end{itemize}
        \item Usability Requirements

\begin{itemize}
        \item The user interface should be intuitive and easy to navigate, requiring no more than three clicks to access any feature.
        \item The system must provide accessibility features for users with disabilities (e.g., screen reader compatibility).
\end{itemize}
        \item Reliability Requirements

\begin{itemize}
        \item The system should have an uptime of 99.9% over a one-year period.
        \item The system must recover from failures within 5 minutes.
\end{itemize}
        \item Scalability Requirements

\begin{itemize}
        \item The system should be able to scale horizontally by adding new servers to handle increased user load.
        \item The application should support a 50% increase in user traffic during peak seasons.
\end{itemize}
        \item Security Requirements
\begin{itemize}

        \item All user data must be encrypted both at rest and in transit.
        \item The system must implement multi-factor authentication for user logins.
\end{itemize}
        \item Maintainability Requirements

\begin{itemize}
        \item The system should allow for easy integration of new features with minimal disruption to existing functionality.
        \item The code-base must be documented in compliance with established coding standards.
\end{itemize}
        \item Compatibility Requirements

\begin{itemize}
        \item The application should be compatible with the latest versions of major web browsers (e.g., Chrome, Firefox, Safari).
        \item The system must integrate seamlessly with existing internal systems and databases.
\end{itemize}
        \item Legal and Regulatory Compliance
\begin{itemize}
        \item All user data handling must adhere to industry standards for privacy and security.
\end{itemize}
\end{enumerate}
\textbf{Importance of Non-Functional Requirements}
\begin{enumerate}[(a).]
        \item User Experience:

            They significantly impact how users perceive the quality and reliability of the system.

        \item System Quality:

            NFRs help ensure that the system meets the desired performance, usability, and security standards.

        \item Risk Management:

            Addressing NFRs early in development can reduce risks associated with performance bottlenecks, security vulnerabilities, and
            user dissatisfaction.

        \item Long-term Viability:

            They help ensure that the system remains maintainable and adaptable over time as technology and user needs evolve.

\end {enumerate}

In summary, non-functional requirements are critical for the overall success of a system, influencing how well it meets user expectations 
and performs under various conditions.

\textbf{\textit{Extra notes from gpt end here! }}

Normally, developers use use case diagrams to represent the functional requirements of a system

Use case diagrams are simple visual tools that show how users interact with a system. They help
explain what the system can do from the user's point of view. The main parts 
of a use case diagram are actors, which are the users or things that use the system, and use cases, which are the actions they can
take, like searching for a book, borrowing a book, or signing up as a new user. The system boundary is a box that shows what is included in the system. For example, in a library management system, the actors could be a "User" and a "Librarian," while the use cases might include searching for books and returning borrowed ones. Use case diagrams are useful because they help everyone understand how users will interact with the system, making it easier to plan and develop the needed features.



\subsubsection{Feasibility study}

A feasibility study is an analysis conducted to determine the viability of a proposed project or solution. It evaluates whether 
the project is practical and achievable within a given time-frame, budget, and resource constraints. The goal of a feasibility study is to
assess various aspects of a project to help stakeholders make informed decisions about whether to proceed, modify, or abandon the idea.

\textbf{Key Components of a Feasibility Study}

\begin{enumerate}
    \item Technical Feasibility:

            Assesses whether the technology and resources needed to implement the project are available and whether the project can be developed using 
            existing technology. If the databases that are required exist, that the languages that exist can meet the requirements, and all the other
            technical factors must be considered in accordance to the requirements.

    \item Economic Feasibility:

            Evaluates the cost-effectiveness of the project. This includes an analysis of the expected costs, potential financial benefits, 
            and overall return on investment.

    \begin{enumerate}
        \item Expenditure
            
        \begin{enumerate}
            \item Direct expenditure 

                Example: Such as the salaries of the developers of a company, the price of the hardware

            \item Indirect expenditure

                Example: When an newly released software's servers crash due to the unexpectedly heavy traffic.  

        \end{enumerate}

        \item Revenue

        \begin{enumerate}
            \item Direct revenue

                Example: such as the product sales, service fees, subscription fees, etc.

            \item Indirect revenue

                Example: Saving time

        \end{enumerate}

    \end{enumerate}

    \item Operational Feasibility:

            Examines how well the proposed project aligns with the organization’s existing operations and whether it can be integrated into 
            current processes.
            
            Example: An organization wants to shift from recording data on paper to using a computer system.
            However, the software developed by the team is too complex and difficult to navigate, with many unnecessary features.
            This complexity can overwhelm the employees, who are not accustomed to using complicated software.
            In this case, the software is not operationally feasible. For individuals who are not very familiar with computers, 
            the developer must design the software to be easy to use with a small learning curve, ensuring it fits smoothly into their workflow.


    \item Legal Feasibility:
           
            Determines if the project complies with legal and regulatory requirements, including permits, licenses, and environmental regulations.
            
    \item Organisational Feasibility: 
        
        Refers to the assessment of whether an organization has the necessary resources, structure, skills, and culture to successfully implement 
        a proposed project. It focuses on evaluating internal capabilities to determine if the organization can support 
        the development, deployment, and operation of the project. This type of feasibility is critical in ensuring that the project aligns with
        the organization's goals and that the necessary human, technical, and management resources are available


\end{enumerate}



\textbf{\textit{Extra notes from gpt starts here! }}

Importance of a Feasibility Study
\begin{enumerate}
    \item Informed Decision-Making: Helps stakeholders understand the potential challenges and benefits, allowing for more informed decisions.
    \item Risk Mitigation: Identifies potential risks and obstacles early in the planning process, enabling the team to address them proactively.
    \item Resource Allocation: Provides insight into the resources required for the project, 
        helping organizations allocate their time, money, and personnel effectively.
    \item Stakeholder Confidence: Demonstrates due diligence to stakeholders and investors, increasing their confidence in the project.
\end{enumerate}


In summary, a feasibility study is an essential step in project planning that assesses various factors to determine whether 
a project is worth pursuing. By thoroughly analyzing the technical, economic, operational, legal, and scheduling aspects, 
organizations can make better-informed decisions that contribute to successful project outcomes.

\textbf{\textit{Extra notes from gpt end here! }}
\vspace{0.2cm}

\textit{At the end of the first phase, after completing all the above steps, it will result in an document called an SRS document also know as the 
Software Requirement Specification. This is the outcome of your first phase, after the requirement gathering and the feasibility analysis.}

\subsection{System design - Design phase.}
the second phase is the System design.
In this phase all the architects and the senior members in a development team will refer to the SRS and then come up with a design
for the software in accordance to the requirement.  

The SRS (Software requirement specification) is given to the architects and senior managers who will the be creating the high level design that 
outlines the system architecture and component 

This is the most important phase as this is where the developer develops the design for the high level code of the software.  

\textit {Create a high level design that outlines the system architecture and components. Define data structures, interfaces, algorithms and overall
system behavior.}
  
The tools that are used:
\begin{itemize}
    \item UML diagrams
    \begin{itemize}
        \item Class Diagrams
        \item Sequence Diagrams
        \item ER Diagrams
        \item DFD
        \item Flow charts
    \end{itemize}    
\end{itemize}    

at the end of this phase the developer will complete an document called the Software Design Document. 

\subsection{Implementation phase - coding}
 
Write and develop the code base upon the design specifications (the SDD at the end of phase two). Then perform unit testing to ensure each individual 
component work as intended. 
 
This design is transformed into an executable code block. Thus the developer can run the program or software and check the functionalities for any
errors or malfunctions.

In order to fulfill the requirements and produce a functional code block that meets all the requirements, in this phase all the developers are involved
as well as the senior developers and the team leads, and more.

At the end of this level the developers will have an executable code, a manual, and not a deploy-able product.  
This manual will teach the end user on how to use the system or the program. 


\subsection{Testing phase}

Conduct various testing, phases such as integration testing, system testing, and user acceptance testing. Identify and fix defects or issues found 
during testing.

\subsubsection{The three types of testing }
\begin{enumerate}
    \item White box testing:


        The testers are allowed to see the internal code structures. In this type of testing the main advantage is that even if the code does function
        and produce the correct output, the testers can see the internal structures and check for errors such as code redundancy, or wrong output for
        some of the internal functions of the code. Usually the developers from the team that originally developed the code for the software might be 
        present.

    \item Black box testing:

        In black box testing the internal code or the structure is unknown to the tester who is testing the code. Where the tester compares the output 
        of the system to the expected output after inserting an input. If the expected output and the actual output are not exactly the same then that 
        means that there is an error or an bug in the software or the system. The tester or the quality assurance 
        team are not provided with any documents that 
        explain the system or any type of access to the internal code.

Example: automated testing can be incorporated to perform black box testing.

    \item Gray box testing: 

        This is where the tester has partial access to the code blocks and internal code. 

\end{enumerate}

The most important of these two types of testing is the white box and black box testing.

Within the software testing phase there is another life cycle.

\subsubsection{Software Testing Life Cycle (STLC)}
The Software Testing Life Cycle is a series of particular
tasks carried out throughout the testing process to guarantee that the software quality objectives are accomplished.

\begin{enumerate}
    \item Requirement analysis:

The tester needs to reanalyse the functional and non-functional requirements to build the test cases  

    \item Test planing:

Plan the test cases that will be implemented

    \item Test case design and development:

Designing the test cases, and record them in a test log book, for the test plan there may be multiple test cases, where in each test case the is 
a description of the inputs that will be inserted and the outputs that are expected for the inserted outputs.

    \item Test environment setup:

        To execute the test cases that have been planned, the tester need to have a proper environmental setup.

    \item Test execution:

Execute the code blocks in any approach such as automated testing or even manual testing. Execute the code blocks in any approach such 
as automated testing or even manual testing.
The outcome will be the output of the results. In the test plan there will be an expected outcome, the tester will then compare the 
expected and the actual outputs. 
\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Input&Instruction to follow&Expected output&System Output&Status (pass/ fail)\\ \hline
 & & & & \\ \hline
 & & & & \\ \hline
 & & & & \\ \hline
 & & & & \\ \hline
 & & & & \\ \hline
\end{tabular}
\end{center}
\caption{Test case}
\end{table}

    \item Test cycle closure:

       Finally after all the testing, and obtaining the results this test cycle is closed. 

\end{enumerate}

This cycle is to be reiterated based on how many sections must be tested. The tester can always restart the cycle for every new section till all the
testing is completed.
\subsubsection{The phases of the Testing phase}

There are four phases in the Testing phase: 

\begin{enumerate}
    \item Unit testing: 

        This is the initial testing which occurs as early as the implementation phase, which is the third phase in the Software Development Life
        Cycle. This is an white box testing as the developers have access to all the internal code blocks.
        While building the code in the Implementation 
        phase the developers run the code to check the code for any bugs in parellel to the coding in the Implementation phase. In Unit testing
        the developer verifies the code in units to assess if the application breaks down or not.

    \item Integration testing:

Where the testing occurs after integration of all the components of code. This is also an white box testing.

    \item System testing:

Checking the executable code, the software for any errors. Checking if all inputs return expected outputs, and that the code's functionality is 
inaccordance to all the functional requirements, and all the non functional requirements. Testing the whole system. This is mainly done by the 
Quality Assurance professionals and the testers, therefore this testing can be classified under all three types of testing (black, white and grey).

    \item Acceptance testing:  

    This phase is done mostly after the deployment of the software or the code, but there is some testing
    before the deployment. Where the final system is tested.\\
    Acceptance testing can be divided into:
    
    \begin{enumerate}
        \item Alpha testing: 
            Alpha testing is something done at the starting inside the software development company before the 
            deployment of the software. An developer
            working on a different team will do the testing again on the software, a member that has not taken part in the development of the software
            that he will be testing at hand.

        \item Beta testing:
            This is done after the deployment, after setting up the application where the customer has demanded it. Here we allow the end users
            to test the software. If the end users come across any bugs inside the system then this bug has to be de-bugged, and the system has to 
            be patched.

    \end{enumerate}
        
\end{enumerate}

Now after all these phases the company has a shippable product which can be used by the users, customers.


\subsection{Deployment phase.}

In this phase the software is deployed to the production enviroment or released to the end users and also within this phase the company must ensure
a smooth transition from the development to the operational enviroment.

There are four deployment phases:

\begin{enumerate}
    \item Direct deployment:

        To stop the old system and to deploy the new system.

    \item Pilot deployment: 



    \item Parellel deployment: 
    \item Phases deployment:
\end{enumerate}

\subsection{Maintainace and support phase}

In this phase the software development company will adress and fix the issues that are reported by the users in the production enviroment, while 
also implementing updates, enhancments, or patches as needed.

\section{Development methodologies}

Software Development Life Cycle (SDLC) models are structured frameworks used to guide the process of developing software applications from conception
to deployment and maintainace. These models provide a systematic approach to managing the various stages of software development, ensuring that 
projects are well organised, predictable, and efficient.

In development methodologies the steps learnt in the previous section SDLC are brought into a structured framework, these frameworks are then applied
when developing different products based on thier nature. All the steps in the SDLC cycle will be used in these development methodologies.

\textbf{WaterFall Model}

\textbf{Spiral Model}

Combines elements of both 

\textbf{}
\end{document}
